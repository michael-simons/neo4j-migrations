<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DatabaseCatalog.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Neo4j Migrations (Core)</a> &gt; <a href="index.source.html" class="el_package">ac.simons.neo4j.migrations.core</a> &gt; <span class="el_source">DatabaseCatalog.java</span></div><h1>DatabaseCatalog.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2020-2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package ac.simons.neo4j.migrations.core;

import ac.simons.neo4j.migrations.core.catalog.Catalog;
import ac.simons.neo4j.migrations.core.catalog.CatalogItem;
import ac.simons.neo4j.migrations.core.catalog.Constraint;
import ac.simons.neo4j.migrations.core.catalog.Index;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;

import org.neo4j.driver.Record;
import org.neo4j.driver.SimpleQueryRunner;
import org.neo4j.driver.Value;
import org.neo4j.driver.Values;
import org.neo4j.driver.types.MapAccessor;

/**
 * Catalog based on the items discoverable inside a Neo4j instance at a given point in time.
 *
 * @author Michael J. Simons
 * @soundtrack The Prodigy - Music For The Jilted Generation
 * @since 1.7.0
 */
final class DatabaseCatalog implements Catalog {

	/**
	 * A map accessor that can filter other map-accessors. It does not support iterating over elements.
	 */
	private static final class FilteredMapAccessor implements MapAccessor {

		private final MapAccessor delegate;

		private final Set&lt;String&gt; filteredKeys;

<span class="fc" id="L57">		FilteredMapAccessor(MapAccessor delegate, Set&lt;String&gt; filter) {</span>
<span class="fc" id="L58">			this.delegate = delegate;</span>
<span class="fc" id="L59">			this.filteredKeys = new HashSet&lt;&gt;();</span>
<span class="fc" id="L60">			this.delegate.keys().forEach(this.filteredKeys::add);</span>
<span class="fc" id="L61">			this.filteredKeys.removeAll(filter);</span>
<span class="fc" id="L62">		}</span>

		@Override
		public Iterable&lt;String&gt; keys() {
<span class="nc" id="L66">			return filteredKeys;</span>
		}

		@Override
		public boolean containsKey(String key) {
<span class="fc" id="L71">			return filteredKeys.contains(key);</span>
		}

		@Override
		public Value get(String key) {
<span class="fc bfc" id="L76" title="All 2 branches covered.">			return filteredKeys.contains(key) ?  delegate.get(key) : Values.NULL;</span>
		}

		@Override
		public int size() {
<span class="nc" id="L81">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public Iterable&lt;Value&gt; values() {
<span class="nc" id="L86">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public &lt;T&gt; Iterable&lt;T&gt; values(Function&lt;Value, T&gt; mapFunction) {
<span class="nc" id="L91">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public Map&lt;String, Object&gt; asMap() {
<span class="nc" id="L96">			throw new UnsupportedOperationException();</span>
		}

		@Override
		public &lt;T&gt; Map&lt;String, T&gt; asMap(Function&lt;Value, T&gt; mapFunction) {
<span class="nc" id="L101">			throw new UnsupportedOperationException();</span>
		}
	}

	static Catalog full(Neo4jVersion version, SimpleQueryRunner queryRunner) {
<span class="nc" id="L106">		return of(version, queryRunner, true, false);</span>
	}

	static Catalog of(Neo4jVersion version, SimpleQueryRunner queryRunner, boolean readOptions) {
<span class="fc" id="L110">		return of(version, queryRunner, readOptions, true);</span>
	}

	private static Catalog of(Neo4jVersion version, SimpleQueryRunner queryRunner, boolean readOptions, boolean filterInternalConstraints) {

<span class="fc" id="L115">		Set&lt;CatalogItem&lt;?&gt;&gt; items = new LinkedHashSet&lt;&gt;();</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">		Function&lt;Record, MapAccessor&gt; mapAccessorMapper = r -&gt; readOptions ? r : new FilteredMapAccessor(r, Collections.singleton(&quot;options&quot;));</span>

<span class="pc" id="L118">		Predicate&lt;Constraint&gt; internalConstraints = c -&gt; true;</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">		if (filterInternalConstraints) {</span>
<span class="fc" id="L120">			internalConstraints = constraint -&gt; Arrays.stream(MigrationsLock.REQUIRED_CONSTRAINTS).noneMatch(constraint::isEquivalentTo);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">			internalConstraints = internalConstraints.and(c -&gt; !Migrations.UNIQUE_VERSION.isEquivalentTo(c));</span>
		}
<span class="fc" id="L123">		queryRunner.run(version.getShowConstraints())</span>
<span class="fc" id="L124">			.stream()</span>
<span class="fc" id="L125">			.map(mapAccessorMapper)</span>
<span class="fc" id="L126">			.map(Constraint::parse)</span>
<span class="fc" id="L127">			.filter(internalConstraints)</span>
<span class="fc" id="L128">			.forEach(items::add);</span>

<span class="fc bfc" id="L130" title="All 4 branches covered.">		Predicate&lt;Index&gt; internalIndexes = index -&gt; index.getType() != Index.Type.LOOKUP &amp;&amp; index.getType() != Index.Type.CONSTRAINT_BACKING_INDEX;</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">		if (filterInternalConstraints) {</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">			internalIndexes = internalIndexes.and(i -&gt; !Migrations.REPEATED_AT.isEquivalentTo(i));</span>
		}
<span class="fc" id="L134">		queryRunner.run(version.getShowIndexes())</span>
<span class="fc" id="L135">			.stream()</span>
<span class="fc" id="L136">			.map(mapAccessorMapper)</span>
<span class="fc" id="L137">			.map(Index::parse)</span>
<span class="fc" id="L138">			.filter(internalIndexes)</span>
<span class="fc" id="L139">			.forEach(items::add);</span>

<span class="fc" id="L141">		return new DatabaseCatalog(items);</span>
	}

	private final Collection&lt;CatalogItem&lt;?&gt;&gt; items;

<span class="fc" id="L146">	private DatabaseCatalog(Set&lt;CatalogItem&lt;?&gt;&gt; items) {</span>
<span class="fc" id="L147">		this.items = items;</span>
<span class="fc" id="L148">	}</span>

	@Override
	public Collection&lt;CatalogItem&lt;?&gt;&gt; getItems() {
<span class="fc" id="L152">		return items;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>