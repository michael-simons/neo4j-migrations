:numbered!:

[[appendix]]
= Appendix

== Glossary

Pending migration:: See _Resolved migration_.
Resolved migration:: A migration that has been resolved in the classpath or the filesystem which has not been yet applied.
Schema database:: A database inside a Neo4j enterprise instance or cluster that stores the schema information from Neo4j-Migrations.
Target database:: A database inside a Neo4j enterprise instance or cluster that is refactored by Neo4j-Migrations.

[[appendix_xml_schemes]]
== XML Schemes

[[appendix_xml_schemes_migration]]
=== `migration.xsd`

Before we jump into the pure joy of an https://en.wikipedia.org/wiki/XML_Schema_(W3C)[XML Schema], lets read in plain english
what our schema can do:

* A `<migration />` can have zero or exactly one `<catalog />` element.
* A `<catalog />` consists of zero or one `<constraints />` and zero or one `<indexes />` elements. In addition, it can indicate
  a `reset` attribute, replacing the current known content with the catalog currently being in definition.
* Both of them can contain zero or more of their individual elements, according to their definition.
* A `<migration />` can have zero or one `<verify />` operations and the `<verify />` operation must be the first operation.
* A `<migration />` can than have zero or more `<create />` and `<drop />` operations *or* exactly one `<apply />` operation.
  The `<apply />` operation is mutual exclusive to all operations working on single items.
* Operations that work on a single item (create and drop) are allowed to define a single item locally. This item
  won't participate in the global catalog.
* Operations that work on a single item can refer to this item by either using the attribute `item` (a free form string)
  or `ref` (an `xs:IDREF`). While the latter is useful for referring to items defined in the same migration (it will usually
  be validated by your tooling), the former is handy to refer to items defined in other migrations.

A catalog item will either have a child-element `<label />` in which case it will always refer to nodes or a mutual
exclusive child-element `<type />` in which it always refers to relationships. The `type` attribute is unrelated
to the target entity. This attribute defines the type of the element (such as unique- or existential constraints).

We do support the following processing instructions:

* `<?assert followed by a valid precondition ?>`
* `<?assume followed by a valid precondition ?>`

Look up valid preconditions <<concepts_preconditions,here>>. The full XMl schema for <<concepts_migrations_catalog-based, catalog-based migrations>> looks like this:

.migration.xsd
[source,xml,indent=0,tabsize=2]
----
include::../neo4j-migrations-core/src/main/resources/ac/simons/neo4j/migrations/core/migration.xsd[]
----

[[appendix_refactorings]]
== Refactorings

Neo4j-Migrations contains a set of ready-to-use database refactorings. These refactorings are all modelled very closely to those available in https://neo4j.com/labs/apoc/4.4/overview/apoc.refactor/[APOC] but *none* of them requires APOC to be installed in your database. The refactorings are mostly designed to work from within a <<concepts_catalog, catalog>> but they work very well on their own to. While they are part of the <<usage_core, Core API>>, they don't depend on a Migration instance. Their API is subject to the same versioning guarantees as the rest of Neo4j-Migrations. Refactorings might evolve into a their module at a later point in time.

=== Renaming labels, types and properties

`ac.simons.neo4j.migrations.core.refactorings.Rename` renames labels, types and properties and requires in its default form only Neo4j 3.5 to work. Custom queries for filtering target entities require Neo4j 4.1, batches Neo4j 4.4.

==== Common methods

`inBatchesOf`:: Enables or disables batching, requires Neo4j 4.4
`withCustomQuery`:: Provides a custom query matching an entity (Node or Label) for renaming. The query must return zero or more rows each containing one item. This feature requires Neo4j 4.1

==== Renaming labels

`Rename.label(String from, String to)` renames all labels on all nodes that are equal the value of `from` to the value of `to`.

As catalog item:

[source,xml]
----
<refactor type="rename.label">
  <parameters>
    <parameter name="from">Engineer</parameter>
    <parameter name="to">DevRel</parameter>
    <!-- Optional custom query -->
    <!--
    <parameter name="customQuery"><![CDATA[
      MATCH (person:Engineer)
      WHERE person.name IN ["Mark", "Jennifer", "Michael"]
      RETURN person
    ]]></parameter>
    -->
    <!-- Optional batch size (requires Neo4j 4.4+) -->
    <!--
    <parameter name="batchSize">23</parameter>
    -->
  </parameters>
</refactor>
----

==== Renaming types

`Rename.type(String from, String to)` renames all types on all relationships that are equal the value of `from` to the value of `to`.

As catalog item:

[source,xml]
----
<refactor type="rename.type">
  <parameters>
    <parameter name="from">COLLEAGUES</parameter>
    <parameter name="to">FROLLEAGUES</parameter>
    <!-- Optional custom query -->
    <!--
    <parameter name="customQuery"><![CDATA[
      MATCH (:Engineer {name: "Jim"})-[rel]->(:Engineer {name: "Alistair"})
      RETURN rel
    ]]></parameter>
    -->
    <!-- Optional batch size (requires Neo4j 4.4+) -->
    <!--
    <parameter name="batchSize">23</parameter>
    -->
  </parameters>
</refactor>
----

==== Renaming node properties

`Rename.nodeProperty(String from, String to)` renames all properties on all nodes that are equal the value of `from` to the value of `to`.

As catalog item:

[source,xml]
----
<refactor type="rename.nodeProperty">
  <parameters>
    <parameter name="from">released</parameter>
    <parameter name="to">ver√∂ffentlicht im Jahr</parameter>
    <!-- Optional custom query -->
    <!--
    <parameter name="customQuery"><![CDATA[
      MATCH (n:Movie) WHERE n.title =~ '.*Matrix.*' RETURN n
    ]]></parameter>
    -->
    <!-- Optional batch size (requires Neo4j 4.4+) -->
    <!--
    <parameter name="batchSize">23</parameter>
    -->
  </parameters>
</refactor>
----

==== Renaming type properties

`Rename.typeProperty(String from, String to)` renames all properties on all relationships that are equal the value of `from` to the value of `to`.

As catalog item:

[source,xml]
----
<refactor type="rename.relationshipProperty">
  <parameters>
    <parameter name="from">roles</parameter>
    <parameter name="to">rollen</parameter>
    <!-- Optional custom query -->
    <!--
    <parameter name="customQuery"><![CDATA[
      MATCH (n:Movie) <-[r:ACTED_IN] -() WHERE n.title =~ '.*Matrix.*' RETURN r
    ]]></parameter>
    -->
    <!-- Optional batch size (requires Neo4j 4.4+) -->
    <!--
    <parameter name="batchSize">23</parameter>
    -->
  </parameters>
</refactor>
----

=== Merging nodes

`Merge.nodes(String source, List<PropertyMergePolicy> mergePolicies)` merges all the nodes, their properties and relationships onto a single node (the first in the list of matched nodes). It is important that your query uses an ordered return for this to work proper.

The `Merge` refactoring requires Neo4j 4.4+.

As catalog item:

[source,xml]
----
<refactor type="merge.nodes">
  <parameters>
    <parameter name="sourceQuery">MATCH (p:Person) RETURN p ORDER BY p.name ASC</parameter>
    <!-- Repeat as often as necessary -->
    <parameter name="mergePolicy">
      <pattern>name</pattern>
      <strategy>KEEP_LAST</strategy>
    </parameter>
    <parameter name="mergePolicy">
      <pattern>.*</pattern>
      <strategy>KEEP_FIRST</strategy>
    </parameter>
  </parameters>
</refactor>
----

[[appendix_extesions]]
== Extensions

=== AsciiDoctor Support (Experimental)

include::../extensions/neo4j-migrations-formats-adoc/README.adoc[leveloffset=+2,tag=content]

=== Markdown Support (Experimental)

include::../extensions/neo4j-migrations-formats-markdown/README.adoc[leveloffset=+2,tag=content]