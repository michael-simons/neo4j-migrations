:numbered!:

[[appendix]]
= Appendix

== Glossary

Pending migration:: See _Resolved migration_.
Resolved migration:: A migration that has been resolved in the classpath or the filesystem which has not been yet applied.
Schema database:: A database inside a Neo4j enterprise instance or cluster that stores the schema information from Neo4j-Migrations.
Target database:: A database inside a Neo4j enterprise instance or cluster that is refactored by Neo4j-Migrations.

[[appendix_xml_schemes]]
== XML Schemes

[[appendix_xml_schemes_migration]]
=== `migration.xsd`

Before we jump into the pure joy of an https://en.wikipedia.org/wiki/XML_Schema_(W3C)[XML Schema], lets read in plain english
what our schema can do:

* A `<migration />` can have zero or exactly one `<catalog />` element.
* A `<catalog />` consists of zero or one `<constraints />` and zero or one `<indexes />` elements. In addition, it can indicate
  a `reset` attribute, replacing the current known content with the catalog currently being in definition.
* Both of them can contain zero or more of their individual elements, according to their definition.
* A `<migration />` can have zero or one `<verify />` operations and the `<verify />` operation must be the first operation.
* A `<migration />` can than have zero or more `<create />` and `<drop />` operations *or* exactly one `<apply />` operation.
  The `<apply />` operation is mutual exclusive to all operations working on single items.
* Operations that work on a single item (create and drop) are allowed to define a single item locally. This item
  won't participate in the global catalog.
* Operations that work on a single item can refer to this item by either using the attribute `item` (a free form string)
  or `ref` (an `xs:IDREF`). While the latter is useful for referring to items defined in the same migration (it will usually
  be validated by your tooling), the former is handy to refer to items defined in other migrations.

A catalog item will either have a child-element `<label />` in which case it will always refer to nodes or a mutual
exclusive child-element `<type />` in which it always refers to relationships. The `type` attribute is unrelated
to the target entity. This attribute defines the type of the element (such as unique- or existential constraints).

We do support the following processing instructions:

* `<?assert followed by a valid precondition ?>`
* `<?assume followed by a valid precondition ?>`

Look up valid preconditions <<concepts_preconditions,here>>. The full XMl schema for <<concepts_migrations_catalog-based, catalog-based migrations>> looks like this:

.migration.xsd
[source,xml,indent=0,tabsize=2]
----
include::../neo4j-migrations-core/src/main/resources/ac/simons/neo4j/migrations/core/migration.xsd[]
----

[[appendix_refactorings]]
== Refactorings

Neo4j-Migrations contains a set of ready-to-use database refactorings. These refactorings are all modelled very closely to those available in https://neo4j.com/labs/apoc/4.4/overview/apoc.refactor/[APOC] but *none* of them requires APOC to be installed in your database. The refactorings are mostly designed to work from within a <<concepts_catalog, catalog>> but they work very well on their own to. While they are part of the <<usage_core, Core API>>, they don't depend on a Migration instance. Their API is subject to the same versioning guarantees as the rest of Neo4j-Migrations. Refactorings might evolve into a their module at a later point in time.

Some refactorings require certain Neo4j versions. If you do support multiple Neo4j versions, define those refactorings as single itemed migrations and add assumptions like in the following example:

.Normalize boolean properties when running Neo4j 4.1+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<migration xmlns="https://michael-simons.github.io/neo4j-migrations">

  <?assume that version is ge 4.1 ?>

  <refactor type="normalize.asBoolean">
    <parameters>
      <parameter name="property">watched</parameter>
      <parameter name="trueValues">
        <value>y</value>
        <value>YES</value>
      </parameter>
      <parameter name="falseValues">
        <value>n</value>
        <value>NO</value>
      </parameter>
    </parameters>
  </refactor>
</migration>
----

=== Merging nodes

`Merge.nodes(String source, List<PropertyMergePolicy> mergePolicies)` merges all the nodes, their properties and relationships onto a single node (the first in the list of matched nodes). It is important that your query uses an ordered return for this to work proper.

The `Merge` refactoring requires Neo4j 4.4+.

As catalog item:

[source,xml]
----
<refactor type="merge.nodes">
  <parameters>
    <parameter name="sourceQuery">MATCH (p:Person) RETURN p ORDER BY p.name ASC</parameter>
    <!-- Repeat as often as necessary -->
    <parameter name="mergePolicy">
      <pattern>name</pattern>
      <strategy>KEEP_LAST</strategy>
    </parameter>
    <parameter name="mergePolicy">
      <pattern>.*</pattern>
      <strategy>KEEP_FIRST</strategy>
    </parameter>
  </parameters>
</refactor>
----

== Normalizing

Normalizing is the process to take an humongous set of properties and other Graph Items and apply a scheme to it.
The normalizing refactoring requires at least Neo4j 4.1, running it with batches requires Neo4j 4.4 or higher.

=== Normalize properties as boolean

Often times database schemes evolved over time, and you find properties with a boolean meaning and a string datatype with content such as `ja`, `Y`, `yes`, `NO` or literal null. To use them proper in queries, you might want to normalize them into a real boolean value. This is done with `Normalize.asBoolean`.

`Normalize.asBoolean` takes in the name of a property and a list of values that are treated as `true` and a list of values that are treated as `false`. A property with a value that is not in any of those lists will be deleted. `null` as value is a non-existent property. However, if either lists contains literal `null`, a property will be created with the corresponding value.

By default all properties of all nodes and relationships will be normalized. To only apply this refactoring to a subset, i.e. only to nodes, you would want to use a custom query.

A Java example looks like this:

[source,java]
----
Normalize.asBoolean(
    "watched",
    List.of("y", "YES", "JA"),
	// List.of does not support literal null,
	// so we need to this the old-school
    Arrays.asList("n", "NO", null)
);
----

The same as a catalog item:

[source,xml]
----
<refactor type="normalize.asBoolean">
  <parameters>
    <parameter name="property">watched</parameter>
    <parameter name="trueValues">
      <value>y</value>
      <value>YES</value>
      <value>JA</value>
    </parameter>
    <parameter name="falseValues">
      <value>n</value>
      <value>NO</value>
      <value />
    </parameter>
    <!-- Optional custom query and batch size -->
    <!--
    <parameter name="customQuery">MATCH (n:Movie) return n</parameter>
    <parameter name="batchSize">42</parameter>
    -->
  </parameters>
</refactor>
----

=== Renaming labels, types and properties

`ac.simons.neo4j.migrations.core.refactorings.Rename` renames labels, types and properties and requires in its default form only Neo4j 3.5 to work. Custom queries for filtering target entities require Neo4j 4.1, batches Neo4j 4.4.

==== Common methods

`inBatchesOf`:: Enables or disables batching, requires Neo4j 4.4
`withCustomQuery`:: Provides a custom query matching an entity (Node or Label) for renaming. The query must return zero or more rows each containing one item. This feature requires Neo4j 4.1

==== Renaming labels

`Rename.label(String from, String to)` renames all labels on all nodes that are equal the value of `from` to the value of `to`.

As catalog item:

[source,xml]
----
<refactor type="rename.label">
  <parameters>
    <parameter name="from">Engineer</parameter>
    <parameter name="to">DevRel</parameter>
    <!-- Optional custom query -->
    <!--
    <parameter name="customQuery"><![CDATA[
      MATCH (person:Engineer)
      WHERE person.name IN ["Mark", "Jennifer", "Michael"]
      RETURN person
    ]]></parameter>
    -->
    <!-- Optional batch size (requires Neo4j 4.4+) -->
    <!--
    <parameter name="batchSize">23</parameter>
    -->
  </parameters>
</refactor>
----

==== Renaming types

`Rename.type(String from, String to)` renames all types on all relationships that are equal the value of `from` to the value of `to`.

As catalog item:

[source,xml]
----
<refactor type="rename.type">
  <parameters>
    <parameter name="from">COLLEAGUES</parameter>
    <parameter name="to">FROLLEAGUES</parameter>
    <!-- Optional custom query -->
    <!--
    <parameter name="customQuery"><![CDATA[
      MATCH (:Engineer {name: "Jim"})-[rel]->(:Engineer {name: "Alistair"})
      RETURN rel
    ]]></parameter>
    -->
    <!-- Optional batch size (requires Neo4j 4.4+) -->
    <!--
    <parameter name="batchSize">23</parameter>
    -->
  </parameters>
</refactor>
----

==== Renaming node properties

`Rename.nodeProperty(String from, String to)` renames all properties on all nodes that are equal the value of `from` to the value of `to`.

As catalog item:

[source,xml]
----
<refactor type="rename.nodeProperty">
  <parameters>
    <parameter name="from">released</parameter>
    <parameter name="to">ver√∂ffentlicht im Jahr</parameter>
    <!-- Optional custom query -->
    <!--
    <parameter name="customQuery"><![CDATA[
      MATCH (n:Movie) WHERE n.title =~ '.*Matrix.*' RETURN n
    ]]></parameter>
    -->
    <!-- Optional batch size (requires Neo4j 4.4+) -->
    <!--
    <parameter name="batchSize">23</parameter>
    -->
  </parameters>
</refactor>
----

==== Renaming type properties

`Rename.typeProperty(String from, String to)` renames all properties on all relationships that are equal the value of `from` to the value of `to`.

As catalog item:

[source,xml]
----
<refactor type="rename.relationshipProperty">
  <parameters>
    <parameter name="from">roles</parameter>
    <parameter name="to">rollen</parameter>
    <!-- Optional custom query -->
    <!--
    <parameter name="customQuery"><![CDATA[
      MATCH (n:Movie) <-[r:ACTED_IN] -() WHERE n.title =~ '.*Matrix.*' RETURN r
    ]]></parameter>
    -->
    <!-- Optional batch size (requires Neo4j 4.4+) -->
    <!--
    <parameter name="batchSize">23</parameter>
    -->
  </parameters>
</refactor>
----

[[appendix_extesions]]
== Extensions

=== AsciiDoctor Support (Experimental)

include::../extensions/neo4j-migrations-formats-adoc/README.adoc[leveloffset=+2,tag=content]

=== Markdown Support (Experimental)

include::../extensions/neo4j-migrations-formats-markdown/README.adoc[leveloffset=+2,tag=content]