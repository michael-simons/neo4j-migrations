= Neo4j Migrations
Michael Simons <michael.simons@neo4j.com>
:doctype: article
:lang: en
:listing-caption: Listing
:source-highlighter: coderay
:icons: font
:latest_version: 0.0.3

image::https://maven-badges.herokuapp.com/maven-central/eu.michael-simons.neo4j/neo4j-migrations/badge.svg[link=https://maven-badges.herokuapp.com/maven-central/eu.michael-simons.neo4j/neo4j-migrations]

[abstract]
--
This is a tool for defining Java based migrations that should be applied and recorded against a Neo4j instance.
The only dependencies are the https://github.com/neo4j/neo4j-java-driver[Neo4j Java driver] and https://github.com/classgraph/classgraph[ClassGraph], the later being used to find migrations on the classpath.

Neo4j Migrations is inspired by https://flywaydb.org[FlywayDB], which is an awesome tool for migration of relational databases.
--

== Usage

Declare the extension as Maven dependency:

[source,xml,subs="verbatim,attributes"]
----
<dependency>
    <groupId>eu.michael-simons.neo4j</groupId>
    <artifactId>neo4j-migrations</artifactId>
    <version>{latest_version}</version>
</dependency>
----

Put your migrations as Java classes into your project:

[source,java]
----
import ac.simons.neo4j.migrations.core.JavaBasedMigration;
import ac.simons.neo4j.migrations.core.MigrationContext;

import org.neo4j.driver.Driver;
import org.neo4j.driver.Session;

public class V001__MyFirstMigration implements JavaBasedMigration {

    @Override
    public void apply(MigrationContext context) {
        try (Session session = context.getSession()) { // <1>
            // Steps necessary for a migration
        }
    }
}
----
<.> It is important that you use the supplied session (or the `SessionConfig` if you want to use another type of `Session`)
    for your session retrieval, otherwise you may  run that migration in a different database than in which the tool itself
    is run. However, you are free in which database you run this. Your mileage may vary.

The class names must start with a `V` followed by digits followed by `__` and than some valid Java class name.

To use them create a `Migrations` instance to scan your project and apply all found migrations:

[source,java]
----
Migrations migrations = new Migrations(
    MigrationsConfig.builder().withPackagesToScan("org.company.changeset1").build(),
    GraphDatabase.driver("bolt://localhost:7687", AuthTokens.basic("neo4j", "secret"))
);

migrations.apply();
----

You're migrations will be recorded as a chain of applied migrations (as nodes with the label `__Neo4jMigration`). They can use the driver any way they like.

There's no rollback yet. If any migration fails, the chain will stop, but will not rollback previous migrations.

=== Cypher script based migrations

You can put Cypher scripts ending with `.cypher` inside your classpath resources under `neo4j/migrations`.
From there on they'll be picked up automatically.

Here's an example:

[source,cypher]
.neo4j/migrations/V007__BondTheNameIsBond.cypher
----
CREATE (agent:`007`) RETURN agent;
UNWIND RANGE(1,6) AS i
WITH i CREATE (n:OtherAgents {idx: '00' + i})
RETURN n
;
----

Scripts can contain multiple statements, separated by a `;` followed by a newline.
Statements will be executed in one transaction by default.
That behaviour can be changed as follows:

[source,java]
----
Migrations migrations= new Migrations(
    MigrationsConfig.builder()
        .withTransactionMode(MigrationsConfig.TransactionMode.PER_STATEMENT)
        .build(),
    driver
);
migrations.apply();
----

If you want Migrations to look at other places, configure it as follows:

[source,java]
----
Migrations migrations = new Migrations(
    MigrationsConfig.builder()
        .withLocationsToScan(
            "classpath:my/awesome/migrations",
            "filesystem:/path/to/migration"
        ).build(),
    GraphDatabase.driver("bolt://localhost:7687", AuthTokens.basic("neo4j", "secret"))
);

migrations.apply();
----
